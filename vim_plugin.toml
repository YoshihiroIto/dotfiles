# プラグイン {{{
# [[plugins]]
# repo        = 'Shougo/dein.vim'
# lazy        = 0

# }}}
# ライブラリ {{{
[[plugins]]
repo        = 'Shougo/vimproc'
lazy        = 0
hook_add    = '''
let g:vimproc#download_windows_dll = 1
'''

[[plugins]]
repo        = 'xolox/vim-misc'
lazy        = 0

[[plugins]]
repo        = 'xolox/vim-shell'
lazy        = 0

[[plugins]]
repo        = 'Shougo/tabpagebuffer.vim'
lazy        = 1
on_path     = '.*'

# [[plugins]]
# repo        = 'osyo-manga/shabadou.vim'
# lazy        = 1

[[plugins]]
repo        = 'kana/vim-submode'
lazy        = 1
on_map      = ['gh', 'gw', ',w']
hook_add    = '''
function! YOI_submode_snap(value, scale)
  return a:value / a:scale * a:scale
endfunction

function! YOI_submode_resize_appwin(x, y)
  let scale = get(g:, 'yoi_resize_appwin_size', 8)

  if a:x != 0
    let &columns = YOI_submode_snap(&columns, scale) + a:x * scale
  endif

  if a:y != 0
    let &lines   = YOI_submode_snap(&lines,   scale) + a:y * scale
  endif
endfunction

function! YOI_submode_move_appwin(x, y)
  let scale = get(g:, 'yoi_move_appwin_size', 64)
  let win_x = getwinposx()
  let win_y = getwinposy()

  if a:x == 0
    let x = win_x
  else
    let x = win_x + a:x * scale

    if win_x != YOI_submode_snap(win_x, scale)
      let x = YOI_submode_snap(x, scale)
    endif
  endif

  if a:y == 0
    let y = win_y
  else
    let y = win_y + a:y * scale

    if win_y != YOI_submode_snap(win_y, scale)
      let y = YOI_submode_snap(y, scale)
    endif
  endif

  execute 'winpos' x y
endfunction
'''
hook_source = '''
let g:submode_timeout          = 0
let g:submode_keep_leaving_key = 1

call submode#enter_with('git_hunk', 'n', 's', 'ghj', ':<C-u>GitGutterNextHunk<CR>zvzz')
call submode#enter_with('git_hunk', 'n', 's', 'ghk', ':<C-u>GitGutterPrevHunk<CR>zvzz')
call submode#map(       'git_hunk', 'n', 's', 'j',   ':<C-u>GitGutterNextHunk<CR>zvzz')
call submode#map(       'git_hunk', 'n', 's', 'k',   ':<C-u>GitGutterPrevHunk<CR>zvzz')

call submode#enter_with('winsize', 'n', 's', 'gwh', '8<C-w>>')
call submode#enter_with('winsize', 'n', 's', 'gwl', '8<C-w><')
call submode#enter_with('winsize', 'n', 's', 'gwj', '4<C-w>-')
call submode#enter_with('winsize', 'n', 's', 'gwk', '4<C-w>+')
call submode#map(       'winsize', 'n', 's', 'h',   '8<C-w>>')
call submode#map(       'winsize', 'n', 's', 'l',   '8<C-w><')
call submode#map(       'winsize', 'n', 's', 'j',   '4<C-w>-')
call submode#map(       'winsize', 'n', 's', 'k',   '4<C-w>+')

let call_resize_appwin = ':<C-u>call YOI_submode_resize_appwin'
let call_move_appwin   = ':<C-u>call YOI_submode_move_appwin'

call submode#enter_with('appwinsize', 'n', 's', ',wH', call_resize_appwin . '(-1, 0)<CR>')
call submode#enter_with('appwinsize', 'n', 's', ',wL', call_resize_appwin . '(+1, 0)<CR>')
call submode#enter_with('appwinsize', 'n', 's', ',wJ', call_resize_appwin . '(0, +1)<CR>')
call submode#enter_with('appwinsize', 'n', 's', ',wK', call_resize_appwin . '(0, -1)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'H',   call_resize_appwin . '(-1, 0)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'L',   call_resize_appwin . '(+1, 0)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'J',   call_resize_appwin . '(0, +1)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'K',   call_resize_appwin . '(0, -1)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'h',   call_resize_appwin . '(-1, 0)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'l',   call_resize_appwin . '(+1, 0)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'j',   call_resize_appwin . '(0, +1)<CR>')
call submode#map(       'appwinsize', 'n', 's', 'k',   call_resize_appwin . '(0, -1)<CR>')

call submode#enter_with('appwinpos',  'n', 's', ',wh', call_move_appwin   . '(-1, 0)<CR>')
call submode#enter_with('appwinpos',  'n', 's', ',wl', call_move_appwin   . '(+1, 0)<CR>')
call submode#enter_with('appwinpos',  'n', 's', ',wj', call_move_appwin   . '(0, +1)<CR>')
call submode#enter_with('appwinpos',  'n', 's', ',wk', call_move_appwin   . '(0, -1)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'H',   call_move_appwin   . '(-1, 0)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'L',   call_move_appwin   . '(+1, 0)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'J',   call_move_appwin   . '(0, +1)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'K',   call_move_appwin   . '(0, -1)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'h',   call_move_appwin   . '(-1, 0)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'l',   call_move_appwin   . '(+1, 0)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'j',   call_move_appwin   . '(0, +1)<CR>')
call submode#map(       'appwinpos',  'n', 's', 'k',   call_move_appwin   . '(0, -1)<CR>')
'''

# }}}
# 表示 {{{
[[plugins]]
repo        = 'YoshihiroIto/molokai'
lazy        = 0

[[plugins]]
repo        = 'itchyny/lightline.vim'
lazy        = 0
hook_add    = '''
let g:lightline#colorscheme#yoi#palette = {
      \   'inactive': {
      \     'left':     [['#585858', '#262626', 240, 235],
      \                  ['#585858', '#121212', 240, 233]],
      \     'right':    [['#262626', '#606060', 235, 241],
      \                  ['#585858', '#262626', 240, 235],
      \                  ['#585858', '#121212', 240, 233]]
      \   },
      \   'insert':   {
      \     'branch':   [['#FFFFFF', '#0087AF', 231,  31]],
      \     'left':     [['#005F5F', '#FFFFFF',  23, 231],
      \                  ['#87DFFF', '#005F87', 117,  24]],
      \     'middle':   [['#87DFFF', '#005F87', 117,  24]],
      \     'right':    [['#005F5F', '#87DFFF',  23, 117],
      \                  ['#87DFFF', '#0087AF', 117,  31],
      \                  ['#87DFFF', '#005F87', 117,  24]]
      \   },
      \   'normal':   {
      \     'branch':   [['#FFFFFF', '#585858', 231, 240]],
      \     'error':    [['#BCBCBC', '#FF0000', 250, 196]],
      \     'left':     [['#195E00', '#07AF00',  22,  34],
      \                  ['#8A8A8A', '#303030', 245, 236]],
      \     'middle':   [['#8A8A8A', '#303030', 245, 236]],
      \     'right':    [['#606060', '#D0D0D0', 241, 252],
      \                  ['#BCBCBC', '#585858', 250, 240],
      \                  ['#9E9E9E', '#303030', 247, 236]],
      \     'warning':  [['#262626', '#B58900', 235, 136]]
      \   },
      \   'replace':  {
      \     'left':     [['#FFFFFF', '#DF0000', 231, 160],
      \                  ['#FFFFFF', '#585858', 231, 240]],
      \     'middle':   [['#8A8A8A', '#303030', 245, 236]],
      \     'right':    [['#606060', '#D0D0D0', 241, 252],
      \                  ['#BCBCBC', '#585858', 250, 240],
      \                  ['#9E9E9E', '#303030', 247, 236]]
      \   },
      \   'tabline':  {
      \     'left':     [['#BCBCBC', '#585858', 250, 240]],
      \     'middle':   [['#303030', '#9E9E9E', 236, 247]],
      \     'right':    [['#BCBCBC', '#4E4E4E', 250, 239]],
      \     'tabsel':   [['#BCBCBC', '#262626', 250, 235]]
      \   },
      \   'visual':   {
      \     'branch':   [['#FFFFFF', '#AF0053', 231, 125]],
      \     'left':     [['#AB2362', '#FFFFFF', 125, 231],
      \                  ['#FF84BA', '#870036', 211,  89]],
      \     'middle':   [['#FF84BA', '#870036', 211,  89]],
      \     'right':    [['#75003D', '#FF87BB',  89, 211],
      \                  ['#FE86BB', '#AF0053', 211, 125],
      \                  ['#FF84BA', '#870036', 211,  89]]
      \   }
      \ }

let g:lightline = {
      \   'colorscheme': 'yoi',
      \   'active': {
      \     'left': [
      \       ['mode',   'paste'],
      \       ['branch', 'gitgutter', 'filename', 'anzu', 'submode']
      \     ],
      \     'right': [
      \       ['syntastic', 'lineinfo'],
      \       ['percent']
      \     ]
      \   },
      \   'component': {'percent': '⭡%3p%%'},
      \   'component_function': {
      \     'fileformat':   'YOI_lightline_fileformat',
      \     'filetype':     'YOI_lightline_filetype',
      \     'fileencoding': 'YOI_lightline_fileencoding',
      \     'modified':     'YOI_lightline_modified',
      \     'readonly':     'YOI_lightline_readonly',
      \     'filename':     'YOI_lightline_filename',
      \     'mode':         'YOI_lightline_mode',
      \     'lineinfo':     'YOI_lightline_lineinfo',
      \     'anzu':         'anzu#search_status',
      \     'submode':      'submode#current'
      \   },
      \   'component_expand': {
      \     'syntastic':    'SyntasticStatuslineFlag',
      \     'branch':       'YOI_lightline_current_branch',
      \     'gitgutter':    'YOI_lightline_git_summary'
      \   },
      \   'component_type': {
      \     'syntastic':    'error',
      \     'branch':       'branch',
      \     'gitgutter':    'branch'
      \   },
      \   'separator': {   'left': '⮀', 'right': '⮂'},
      \   'subseparator': {'left': '⮁', 'right': '⮃'},
      \   'tabline': {
      \     'left':  [['tabs']],
      \     'right': [['filetype', 'fileformat', 'fileencoding']]
      \   },
      \   'tabline_separator': {   'left': '⮀', 'right': '⮂'},
      \   'tabline_subseparator': {'left': '⮁', 'right': '⮃'},
      \   'mode_map': {
      \     'n':      'N',
      \     'i':      'I',
      \     'R':      'R',
      \     'v':      'V',
      \     'V':      'VL',
      \     'c':      'C',
      \     "\<C-v>": 'VB',
      \     's':      'S',
      \     'S':      'SL',
      \     "\<C-s>": 'SB',
      \     '?':      ' '
      \   }
      \ }

function! YOI_lightline_mode()
  return  &filetype ==# 'unite'    ? 'Unite'    :
        \ &filetype ==# 'vimfiler' ? 'VimFiler' :
        \ &filetype ==# 'vimshell' ? 'VimShell' :
        \ &filetype ==# 'quickrun' ? 'Quickrun' :
        \ &filetype ==# 'agit'     ? 'Agit'     :
        \ winwidth(0) > 50 ? lightline#mode() : ''
endfunction

function! YOI_lightline_modified()
  if s:is_lightline_no_disp_group()
    return ''
  endif

  return &modified ? '+' : &modifiable ? '' : '-'
endfunction

function! YOI_lightline_readonly()
  if s:is_lightline_no_disp_filetype()
    return ''
  endif

  return &readonly ? '⭤' : ''
endfunction

function! YOI_lightline_filename()
  try
    return (empty(YOI_lightline_readonly()) ? '' : YOI_lightline_readonly() . ' ') .
          \ (&filetype ==# 'unite'    ? unite#get_status_string()    :
          \  &filetype ==# 'vimfiler' ? vimfiler#get_status_string() :
          \  &filetype ==# 'vimshell' ? vimshell#get_status_string() :
          \  &filetype ==# 'quickrun' ? ''                           :
          \  empty(expand('%:t')) ? '[No Name]' : expand('%:t')) .
          \ (empty(YOI_lightline_modified()) ? '' : ' ' . YOI_lightline_modified())
  catch
    return ''
  endtry
endfunction

function! YOI_lightline_current_branch()
  if s:is_lightline_no_disp_filetype()
    return ''
  endif

  if !YOI_is_in_git_branch()
    return ''
  endif

  if &filetype !=# 'vimfiler'
    try
      let branch = fugitive#head()
      return empty(branch) ? '' : '⭠ ' . branch
    catch
      return ''
    endtry
  endif

  return ''
endfunction

function! YOI_lightline_fileformat()
  if s:is_lightline_no_disp_group()
    return ''
  endif

  return &fileformat
endfunction

function! YOI_lightline_filetype()
  if s:is_lightline_no_disp_group()
    return ''
  endif

  return empty(&filetype) ? 'no filetype' : &filetype
endfunction

function! YOI_lightline_fileencoding()
  if s:is_lightline_no_disp_group()
    return ''
  endif

  return empty(&fileencoding) ? &encoding : &fileencoding
endfunction

function! YOI_lightline_git_summary()
  if s:is_lightline_no_disp_group()
    return ''
  endif

  if !YOI_is_in_git_branch()
    return ''
  endif

  try
    let summary = GitGutterGetHunkSummary()
    return printf('%s%d %s%d %s%d',
          \ g:gitgutter_sign_added,    summary[0],
          \ g:gitgutter_sign_modified, summary[1],
          \ g:gitgutter_sign_removed,  summary[2])
  catch
    return ''
  endtry
endfunction

function! YOI_lightline_lineinfo()
  if winwidth(0) <= 50
    return ''
  endif

  return printf('%4d/%d : %-3d', line('.'), line('$'), col('.'))
endfunction

function! s:is_lightline_no_disp_filetype()
  return &filetype =~# 'vimfiler\|unite\|vimshell\|quickrun\|agit'
endfunction

function! s:is_lightline_no_disp_group()
  if winwidth(0) <= 50
    return 1
  endif

  if s:is_lightline_no_disp_filetype()
    return 1
  endif

  return 0
endfunction

Autocmd CursorHold,CursorHoldI * call lightline#update()
'''

[[plugins]]
repo        = 'LeafCage/foldCC.vim'
lazy        = 1
on_ft       = ['vim', 'xml', 'toml']
hook_add    = '''
let g:foldCCtext_enable_autofdc_adjuster = 1
let g:foldCCtext_tail                    =
      \ 'printf("[ %4d lines  Lv%-2d]", v:foldend - v:foldstart + 1, v:foldlevel)'

set foldtext=FoldCCtext()
'''

# [[plugins]]
# repo        = 'scrooloose/syntastic'
# lazy        = 1
# on_ft       = ['go', 'ruby', 'python']
# hook_add    = '''
# Autocmd BufWritePost *.{go,rb,py} call lightline#update()
# '''

[[plugins]]
repo        = 'itchyny/vim-parenmatch'
lazy        = 1
on_path     = '.*'
hook_source = '''
let g:parenmatch_highlight = 0
highlight ParenMatch guifg=#000000 guibg=#FD971F gui=bold
'''

[[plugins]]
repo        = 'Konfekt/FastFold'
lazy        = 1
on_path     = '.*'

# }}}
# 検索 {{{
[[plugins]]
repo        = 'osyo-manga/vim-anzu'
lazy        = 1
on_map      = '<Plug>'
hook_add    = '''
" 一定時間キー入力がないとき、ウインドウを移動したとき、タブを移動したときに
" 検索ヒット数の表示を消去する
let s:anzu_display_count = 0
function! YOI_begin_display_anzu()
  let s:anzu_display_count = 2000 / &updatetime
  call YOI_refresh_screen()
endfunction

function! YOI_update_display_anzu()
  if s:anzu_display_count >= 0
    let s:anzu_display_count -= 1
    " call s:continue_cursor_hold()

    " http://d.hatena.ne.jp/osyo-manga/20121102/1351836801
    call feedkeys(mode() ==# 'i' ? "\<C-g>\<Esc>" : "g\<Esc>", 'n')
  else
    call YOI_clear_display_anzu()
  endif
endfunction

function! YOI_clear_display_anzu()
  try
    call anzu#clear_search_status()
  catch
  endtry
endfunction

Autocmd CursorHold,CursorHoldI * call YOI_update_display_anzu()
Autocmd WinLeave,TabLeave      * call YOI_clear_display_anzu()
'''

[[plugins]]
repo        = 'haya14busa/vim-asterisk'
lazy        = 1
on_map      = '<Plug>'

[[plugins]]
repo        = 'k-takata/matchit.vim'
lazy        = 1
on_path     = '.*'
hook_source = '''
silent! execute 'doautocmd Filetype' &filetype
'''

[[plugins]]
repo        = 'haya14busa/incsearch.vim'
lazy        = 1
on_cmd      = 'IncSearchNoreMap'
on_map      = '<Plug>'
hook_add    = '''
map / <Plug>(incsearch-forward)
map ? <Plug>(incsearch-backward)

map  <silent> n  <Plug>(incsearch-nohl-n)
map  <silent> N  <Plug>(incsearch-nohl-N)
nmap <silent> n  <Plug>(incsearch-nohl)
      \          <Plug>(anzu-n)
      \          zv
      \          :call YOI_begin_display_anzu()<CR>
nmap <silent> N  <Plug>(incsearch-nohl)
      \          <Plug>(anzu-N)
      \          zv
      \          :call YOI_begin_display_anzu()<CR>

map  <silent> *  <Plug>(incsearch-nohl0)<Plug>(asterisk-z*)
map  <silent> g* <Plug>(incsearch-nohl0)<Plug>(asterisk-gz*)
map  <silent> #  <Plug>(incsearch-nohl0)<Plug>(asterisk-z#)
map  <silent> g# <Plug>(incsearch-nohl0)<Plug>(asterisk-gz#)
'''
hook_source = '''
let g:incsearch#auto_nohlsearch   = 1
let g:incsearch#emacs_like_keymap = 1
let g:incsearch#magic             = '\v'
'''

[[plugins]]
repo        = 'rhysd/clever-f.vim'
lazy        = 1
on_map      = '<Plug>'
hook_add    = '''
nmap f <Plug>(clever-f-f)
xmap f <Plug>(clever-f-f)
omap f <Plug>(clever-f-f)
nmap F <Plug>(clever-f-F)
xmap F <Plug>(clever-f-F)
omap F <Plug>(clever-f-F)
'''
hook_source = '''
let g:clever_f_not_overwrites_standard_mappings = 1
let g:clever_f_ignore_case                      = 1
let g:clever_f_smart_case                       = 1
let g:clever_f_across_no_line                   = 1
let g:clever_f_use_migemo                       = 1
let g:clever_f_chars_match_any_signs            = ';'
let g:clever_f_mark_char_color                  = 'Clever_f_mark_char'

highlight default Clever_f_mark_char ctermfg=Green ctermbg=NONE cterm=underline
      \                              guifg=Green   guibg=NONE   gui=underline
'''

# }}}
# 補完 {{{
[[plugins]]
repo        = 'Shougo/neocomplete.vim'
lazy        = 1
on_i        = 1
hook_add    = '''
augroup InitializeNeocomplete
  autocmd!
  autocmd VimEnter,FocusLost,CursorHold,CursorHoldI * call s:initialize_neocomplete()
augroup END

let s:initialize_neocomplete_delay = 2*2
function! s:initialize_neocomplete()
  let s:initialize_neocomplete_delay -= 1
  if s:initialize_neocomplete_delay > 0
    return
  endif

  call neocomplete#initialize()

  augroup InitializeNeocomplete
    autocmd!
  augroup END
endfunction
'''
hook_source = '''
let g:neocomplete#enable_at_startup       = 1
let g:neocomplete#enable_ignore_case      = 1
let g:neocomplete#enable_smart_case       = 1
let g:neocomplete#enable_auto_delimiter   = 1
let g:neocomplete#enable_fuzzy_completion = 0
let g:neocomplete#enable_refresh_always   = 1
let g:neocomplete#enable_prefetch         = 1

let g:neocomplete#auto_completion_start_length      = 3
let g:neocomplete#manual_completion_start_length    = 0
let g:neocomplete#sources#syntax#min_keyword_length = 3
let g:neocomplete#min_keyword_length                = 3
let g:neocomplete#force_overwrite_completefunc      = 1
let g:neocomplete#skip_auto_completion_time         = '0.2'

let g:neocomplete#sources#dictionary#dictionaries = {
      \   'default':  '',
      \   'vimshell': '~/.vimshell_hist'
      \ }

let g:neocomplete#sources#vim#complete_functions = {
      \   'Unite':               'unite#complete_source',
      \   'VimShellExecute':     'vimshell#vimshell_execute_complete',
      \   'VimShellInteractive': 'vimshell#vimshell_execute_complete',
      \   'VimShellTerminal':    'vimshell#vimshell_execute_complete',
      \   'VimShell':            'vimshell#complete',
      \   'VimFiler':            'vimfiler#complete'
      \ }

" 日本語は収集しない
let g:neocomplete#keyword_patterns = {
      \   '_': '\h\w*'
      \ }

let g:neocomplete#sources#omni#input_patterns = {
      \   'c':           '\%(\.\|->\)\h\w*',
      \   'disable_cpp': '\h\w*\%(\.\|->\)\h\w*\|\h\w*::',
      \   'cs':          '[a-zA-Z0-9.]\{2\}',
      \   'typescript':  '\h\w*\|[^. \t]\.\w*',
      \   'ruby':        '[^. *\t]\.\w*\|\h\w*::'
      \ }

let g:neocomplete#force_omni_input_patterns = {
      \   'c':      '[^.[:digit:] *\t]\%(\.\|->\)\w*',
      \   'disable_cpp':    '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*',
      \   'objc':   '[^.[:digit:] *\t]\%(\.\|->\)\w*',
      \   'objcpp': '[^.[:digit:] *\t]\%(\.\|->\)\w*\|\h\w*::\w*',
      \   'cs':     '[^.[:digit:] *\t]\%(\.\)\w*\|\h\w*::\w*'
      \ }

let g:neocomplete#delimiter_patterns = {
      \   'c':   ['.', '->'],
      \   'disable_cpp': [' ::', '.'],
      \   'cs':  ['.'],
      \   'vim': ['#', '.']
      \ }

let g:neocomplete#sources#file_include#exts = {
      \   'c':   ['', 'h'],
      \   'cpp': ['', 'h', 'hpp', 'hxx'],
      \   'cs':  ['', 'Designer.cs']
      \ }

call neocomplete#custom#source('file', 'rank', 10)
'''

[[plugins]]
repo        = 'Shougo/neoinclude.vim'
lazy        = 1
depends     = 'neocomplete.vim'
on_i        = 1

[[plugins]]
repo        = 'Shougo/neosnippet.vim'
lazy        = 1
depends     = 'neocomplete.vim'
on_i        = 1
hook_add    = '''
imap <expr> <Tab> neosnippet#expandable_or_jumpable() ? '<Plug>(neosnippet_expand_or_jump)'
      \                                               : '<Tab>'
smap <expr> <Tab> neosnippet#expandable_or_jumpable() ? '<Plug>(neosnippet_expand_or_jump)'
      \                                               : '<Tab>'
'''
hook_source = '''
let g:neosnippet#disable_runtime_snippets = {'_': 1}
let g:neosnippet#snippets_directory       = g:YOI_dotvim_dir . '/snippets'

let snippets_local = expand(g:YOI_dotvim_dir . '/snippets.local')
if isdirectory(snippets_local)
  let g:neosnippet#snippets_directory .= ',' . snippets_local
endif

call neocomplete#custom#source('neosnippet', 'rank', 1000)
'''

# }}}
# 移動 {{{
# [[plugins]]
# repo        = 'deris/parajump'
# lazy        = 1
# on_map      = '<Plug>'

# }}}
# 編集 {{{
[[plugins]]
repo        = 'tomtom/tcomment_vim'
lazy        = 1
on_func     = 'tcomment'
on_map      = 'gc'
on_cmd      = 'TComment'

[[plugins]]
repo        = 'osyo-manga/vim-over'
lazy        = 1
on_cmd      = 'OverCommandLine'
hook_add    = '''
let g:over_command_line_key_mappings = {"\<C-j>": "\<Esc>"}

nnoremap <silent> <Leader>s  :OverCommandLine<CR>%s/
vnoremap <silent> <Leader>s  :OverCommandLine<CR>s/
nnoremap <silent> <Leader>rs :<C-u>OverCommandLine<CR>%s///g<Left><Left>
vnoremap <silent> <Leader>rs :OverCommandLine<CR>s///g<Left><Left>

augroup InitializeOver
  autocmd!
  autocmd VimEnter,FocusLost,CursorHold,CursorHoldI * call s:initialize_over()
augroup END

let s:initialize_over_delay = 2*1
function! s:initialize_over()
  let s:initialize_over_delay -= 1
  if s:initialize_over_delay > 0
    return
  endif

  call over#load()

  augroup InitializeOver
    autocmd!
  augroup END
endfunction
'''

[[plugins]]
repo        = 'LeafCage/yankround.vim'
lazy        = 1
on_map      = '<Plug>'
hook_add    = '''
let g:yankround_use_region_hl = 1

function! s:yankround_pre(count1)
  return (col('.') >= col('$') ? '$' : '') . ":\<C-u>set virtualedit=block\<CR>" . a:count1
endfunction
nmap <silent><expr> p     <SID>yankround_pre(v:count1) . '<Plug>(yankround-p)'
xmap <silent><expr> p     <SID>yankround_pre(v:count1) . '<Plug>(yankround-p)'
nmap <silent><expr> P     <SID>yankround_pre(v:count1) . '<Plug>(yankround-P)'
nmap <silent><expr> gp    <SID>yankround_pre(v:count1) . '<Plug>(yankround-gp)'
xmap <silent><expr> gp    <SID>yankround_pre(v:count1) . '<Plug>(yankround-gp)'
nmap <silent><expr> gP    <SID>yankround_pre(v:count1) . '<Plug>(yankround-gP)'
nmap <silent>       <C-p> <Plug>(yankround-prev)
nmap <silent>       <C-n> <Plug>(yankround-next)
'''

[[plugins]]
repo        = 'nishigori/increment-activator'
lazy        = 1
on_map      = ['<C-x>', '<C-a>']
hook_add    = '''
let g:increment_activator_filetype_candidates = {
      \   '_':   [['width', 'height']],
      \   'cs':  [['private', 'protected', 'public', 'internal'],
      \           ['abstract', 'virtual', 'override']],
      \   'cpp': [['private', 'protected', 'public']]
      \ }
'''

[[plugins]]
repo        = 'junegunn/vim-easy-align'
lazy        = 1
on_map      = '<Plug>(EasyAlign)'
hook_add    = '''
nmap <silent> <Leader>a=       v<Plug>(textobj-indent-i)<Plug>(EasyAlign)=
nmap <silent> <Leader>a:       v<Plug>(textobj-indent-i)<Plug>(EasyAlign):
nmap <silent> <Leader>a,       v<Plug>(textobj-indent-i)<Plug>(EasyAlign)*,
nmap <silent> <Leader>a<Space> v<Plug>(textobj-indent-i)<Plug>(EasyAlign)*<Space>
nmap <silent> <Leader>a\|      v<Plug>(textobj-indent-i)<Plug>(EasyAlign)*\|
xmap <silent> <Leader>a=       <Plug>(EasyAlign)=
xmap <silent> <Leader>a:       <Plug>(EasyAlign):
xmap <silent> <Leader>a,       <Plug>(EasyAlign)*,
xmap <silent> <Leader>a<Space> <Plug>(EasyAlign)*<Space>
xmap <silent> <Leader>a\|      <Plug>(EasyAlign)*\|
'''

# [[plugins]]
# repo        = 'thinca/vim-qfreplace'
# lazy        = 1
# on_ft       = ['unite', 'quickfix']

[[plugins]]
repo        = 'tpope/vim-endwise'
lazy        = 1
on_ft       = ['vim', 'ruby', 'lua']
hook_add    = '''
" http://cohama.hateblo.jp/entry/20121017/1350482411
let g:endwise_no_mappings = 1
AutocmdFT lua,ruby,vim imap <buffer> <CR> <CR><Plug>DiscretionaryEnd
'''

[[plugins]]
repo        = 'kana/vim-smartinput'
lazy        = 1
on_i        = 1
hook_source = '''
call smartinput#clear_rules()
call smartinput#define_default_rules()
'''

# }}}
# ファイル {{{
[[plugins]]
repo        = 'kana/vim-altr'
lazy        = 1
on_map      = '<Plug>'
hook_add    = '''
nmap ga <Plug>(altr-forward)
nmap gA <Plug>(altr-back)

function! YOI_altr_define(...)
  for parent in ['', '/*', '/*/*', '/*/*/*']
    call altr#define(map(copy(a:000), 'printf(v:val, "' . parent . '")'))
  endfor
endfunction
'''
hook_source = '''
" MVVM
AutocmdFT cs,xml call altr#define(  '%Model.cs',
      \                             '%Vm.cs',
      \                             '%.xaml',
      \                             '%.xaml.cs')
AutocmdFT cs,xml call YOI_altr_define('Models%s/%%Model.cs',
      \                             'ViewModels%s/%%Vm.cs',
      \                             'Views%s/%%.xaml',
      \                             'Views%s/%%.xaml.cs')
AutocmdFT cs,xml call altr#define(  '%Model.cs',
      \                             '%ViewModel.cs',
      \                             '%.xaml',
      \                             '%.xaml.cs')
AutocmdFT cs,xml call YOI_altr_define('Models%s/%%Model.cs',
      \                             'ViewModels%s/%%ViewModel.cs',
      \                             'Views%s/%%.xaml',
      \                             'Views%s/%%.xaml.cs')

" xaml
AutocmdFT cs,xml call altr#define(  '%.xaml',
      \                             '%.xaml.cs')
AutocmdFT cs,xml call altr#define(  '%.cs',
      \                             '%.*.cs')

" C++
AutocmdFT cpp call altr#define(     '%.cpp',
      \                             '%.*.cpp',
      \                             '%.h')
AutocmdFT cpp call YOI_altr_define(   'src%s/%%.cpp',
      \                             'include%s/%%.h')
'''

[[plugins]]
repo        = 'YoshihiroIto/vim-auto-mirroring'
lazy        = 1
on_path     = '.*'
hook_add    = '''
let g:auto_mirroring_dir =  g:YOI_cache_dir . '/mirror'
'''

# }}}
# アプリ {{{
[[plugins]]
repo        = 'YoshihiroIto/vim-icondrag'
lazy        = 1
on_path     = '.*'
hook_source = '''
call icondrag#enable()
'''

[[plugins]]
repo        = 'beckorz/previm'
lazy        = 1
depends     = 'open-browser.vim'
on_ft       = 'markdown'
hook_add    = '''
if has('win32')
  let g:previm_open_cmd = 'C:\\Program\ Files\ (x86)\\Google\\Chrome\\Application\\chrome.exe'
endif
'''

[[plugins]]
repo        = 'tyru/open-browser.vim'
lazy        = 1
on_map      = '<Plug>(openbrowser'
hook_add    = '''
let g:openbrowser_no_default_menus = 1
let g:netrw_nogx = 1
nmap gx <Plug>(openbrowser-smart-search)
vmap gx <Plug>(openbrowser-smart-search)
'''

[[plugins]]
repo        = 'Shougo/vimfiler.vim'
lazy        = 1
depends     = 'unite.vim'
on_map      = '<Plug>'
on_path     = '.*'
hook_add    = '''
noremap <silent> [App]f :<C-u>VimFilerBufferDir<CR>
'''
hook_source = '''
  AutocmdFT vimfiler nmap     <buffer><expr>   <CR>
        \                         vimfiler#smart_cursor_map('<Plug>(vimfiler_cd_file)',
        \                                                   '<Plug>(vimfiler_edit_file)')
  AutocmdFT vimfiler nmap     <buffer><expr>   <C-j>
        \                         vimfiler#smart_cursor_map('<Plug>(vimfiler_exit)',
        \                                                   '<Plug>(vimfiler_exit)')
  AutocmdFT vimfiler nnoremap <silent><buffer> J :<C-u>Unite bookmark<CR>
  AutocmdFT vimfiler nnoremap <silent><buffer> / :<C-u>Unite file -horizontal<CR>
  AutocmdFT vimfiler nnoremap <silent><buffer> gr
        \                         :<C-u>Unite -no-split -buffer-name=grep grep:./<CR>

  let g:vimfiler_as_default_explorer        = 1
  let g:vimfiler_force_overwrite_statusline = 0
  let g:vimfiler_ignore_pattern             = []
  let g:vimfiler_tree_leaf_icon             = ' '
  let g:vimfiler_readonly_file_icon         = '⭤'
  let g:unite_kind_file_use_trashbox        = 1
'''
hook_post_source = '''
  call vimfiler#custom#profile('default', 'context', {'auto_cd': 1})
'''

# [[plugins]]
# repo        = 'rhysd/wandbox-vim'
# lazy        = 1
# hook_source = '''
# " wandbox.vim で quickfix を開かないようにする
# let g:wandbox#open_quickfix_window = 0
# let g:wandbox#default_compiler     = {'cpp': 'clang-head'}
# '''

[[plugins]]
repo        = 'Shougo/vimshell.vim'
lazy        = 1
on_cmd      = 'VimShellPop'
hook_add    = '''
noremap <silent> [App]s :<C-u>VimShellPop<CR>

let g:shell_mappings_enabled = 0
let g:vimshell_popup_height   = 40
let g:vimshell_prompt_pattern = '^\%(\f\|\\.\)\+> '
let g:vimshell_prompt_expr    =
      \ 'escape(substitute(fnamemodify(getcwd(), ":~").">", "\\", "/", "g"), "\\[]()?! ")." "'
'''

[[plugins]]
repo        = 'glidenote/memolist.vim'
lazy        = 1
depends     = 'unite.vim'
on_cmd      = ['MemoNew', 'MemoList', 'MemoGrep']
hook_add    = '''
noremap <silent> [App]mn :<C-u>MemoNew<CR>
noremap <silent> [App]ml :<C-u>MemoList<CR>
noremap <silent> [App]mg :<C-u>MemoGrep<CR>

let g:memolist_unite        = 1
let g:memolist_memo_suffix  = 'md'
let g:memolist_unite_source = 'memolist'
let g:memolist_path         = g:YOI_dropbox_dir . '/memo'
'''

# [[plugins]]
# repo        = 'thinca/vim-quickrun'
# lazy        = 1
# depends     = ['shabadou.vim', 'wandbox-vim']
# on_map      = '<Plug>'
# hook_add    = '''
# noremap <silent> [App]r :<C-u>QuickRun<CR>
#
# let g:quickrun_config = {
#       \   '_': {
#       \     'hook/close_unite_quickfix/enable_hook_loaded': 1,
#       \     'hook/unite_quickfix/enable_failure':           1,
#       \     'hook/close_quickfix/enable_exit':              1,
#       \     'hook/close_buffer/enable_failure':             1,
#       \     'hook/close_buffer/enable_empty_data':          1,
#       \     'outputter':                                    'multi:buffer:quickfix',
#       \     'runner':                                       'vimproc',
#       \     'runner/vimproc/updatetime':                    40
#       \   },
#       \   'cpp/wandbox': {
#       \     'runner':                                       'wandbox',
#       \     'runner/wandbox/compiler':                      'clang-head',
#       \     'runner/wandbox/options':                       'warning,c++1y,boost-1.55'
#       \   },
#       \   'lua': {
#       \     'type':                                         'lua/vim'
#       \   }
#       \ }
# '''

# }}}
# Unite {{{
[[plugins]]
repo        = 'Shougo/unite.vim'
lazy        = 1
depends     = 'neomru.vim'
on_cmd      = ['Unite', 'UniteResume', 'UniteWithCursorWord']
hook_add    = '''
nnoremap [Unite] <Nop>
xnoremap [Unite] <Nop>
nmap     <Space> [Unite]
xmap     <Space> [Unite]

nnoremap <silent> [Unite]cg   :<C-u>Unite -no-split -buffer-name=grep        grep<CR>
nnoremap <silent> [Unite]gg   :<C-u>Unite -no-split -buffer-name=grep        grep:./<CR>
nnoremap <silent> [Unite]ccg  :<C-u>Unite -no-split -buffer-name=grep        grep:../<CR>
nnoremap <silent> [Unite]cccg :<C-u>Unite -no-split -buffer-name=grep        grep:../../<CR>
nnoremap <silent> [Unite]pg   :<C-u>Unite -no-split -buffer-name=grep        grep:!<CR>
nnoremap <silent> [Unite]f    :<C-u>Unite           -buffer-name=buffer      buffer<CR>
nnoremap <silent> [Unite]j    :<C-u>Unite           -buffer-name=bookmark    bookmark<CR>
nnoremap <silent> [Unite]l    :<C-u>Unite -no-split -buffer-name=line        line<CR>
nnoremap <silent> [Unite]o    :<C-u>Unite -vertical -buffer-name=outline     outline<CR>
nnoremap <silent> [Unite]q    :<C-u>Unite -no-quit  -buffer-name=quickfix    quickfix<CR>
nnoremap <silent> [Unite]m    :<C-u>Unite -no-split -buffer-name=neomru/file neomru/file<CR>
nnoremap <silent> [Unite]v    :<C-u>call YOI_execute_if_on_git_branch(
      \                     'Unite -no-split -buffer-name=giti            giti')<CR>
nnoremap <silent> [Unite]b    :<C-u>call YOI_execute_if_on_git_branch(
      \                     'Unite -no-split -buffer-name=giti/branch_all giti/branch_all')<CR>

nnoremap <silent> [Unite]rr   :<C-u>UniteResume<CR>
nnoremap <silent> [Unite]rg   :<C-u>UniteResume grep<CR>
nnoremap <silent> [Unite]rf   :<C-u>UniteResume buffer<CR>
nnoremap <silent> [Unite]rj   :<C-u>UniteResume bookmark<CR>
nnoremap <silent> [Unite]rl   :<C-u>UniteResume line<CR>
nnoremap <silent> [Unite]ro   :<C-u>UniteResume outline<CR>
nnoremap <silent> [Unite]rq   :<C-u>UniteResume quickfix<CR>
nnoremap <silent> [Unite]rm   :<C-u>UniteResume neomru/file<CR>
nnoremap <silent> [Unite]rv   :<C-u>UniteResume giti<CR>
nnoremap <silent> [Unite]rb   :<C-u>UniteResume giti/branch_all<CR>

nnoremap <silent> [Unite]e  :<C-u>Unite -no-split -buffer-name=everything everything<CR>
nnoremap <silent> [Unite]re :<C-u>UniteResume everything<CR>
'''
hook_source = '''
  let g:unite_force_overwrite_statusline = 0
  let g:unite_source_alias_aliases       = {
        \   'memolist': {
        \       'source': 'file'
        \   },
        \   'var': {
        \       'source': 'output',
        \       'args':   'let'
        \   },
        \   'message': {
        \       'source': 'output',
        \       'args':   'message'
        \   }
        \ }

"  if executable('jvgrep')
"    let g:unite_source_grep_command       = 'jvgrep'
"    let g:unite_source_grep_default_opts  =
"          \ '-8 -r -i -I ' .
"          \ '--exclude ''\.(git|svn|vs|o|a|exe|dll|pdb|nupkg)$|(\bobj\b|\bbin\b)'' '
"    let g:unite_source_grep_recursive_opt = '-R'
"    let g:unite_source_grep_encoding      = 'utf-8'
"  endif

"  if executable('pt')
"    let g:unite_source_grep_command       = 'pt'
"    let g:unite_source_grep_default_opts  = '--nogroup --nocolor'
"    let g:unite_source_grep_recursive_opt = ''
"    let g:unite_source_grep_encoding      = 'utf-8'
"  endif

  " https://github.com/dalance/amber
  if executable('ambs')
    let g:unite_source_grep_command       = 'ambs'
    let g:unite_source_grep_default_opts  = '--column --no-color'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_encoding      = 'utf-8'
  endif

  call unite#custom#profile('default', 'context', {
        \   'direction':        'rightbelow',
        \   'hide_icon':        0,
        \   'ignorecase':       1,
        \   'prompt':           '>>',
        \   'prompt_direction': 'top',
        \   'smartcase':        1,
        \   'start_insert':     1,
        \   'vertical':         0,
        \   'winwidth':         60
        \ })

  call unite#custom_default_action('source/bookmark/directory', 'vimfiler')
  call unite#custom_default_action('directory',                 'vimfiler')
  call unite#custom_default_action('neomru/directory',          'vimfiler')

  call unite#custom#source('memolist',        'sorters',        ['sorter_ftime', 'sorter_reverse'])
  call unite#custom#source('everything',      'max_candidates', 500)
  call unite#custom#source('grep',            'max_candidates', 0)
  call unite#custom#source('line',            'max_candidates', 0)
  call unite#custom#source('giti/branch_all', 'max_candidates', 0)

  AutocmdFT unite nnoremap <silent><buffer><expr> <C-r> unite#do_action('replace')
  AutocmdFT unite inoremap <silent><buffer><expr> <C-r> unite#do_action('replace')
  AutocmdFT unite nmap     <silent><buffer>       <C-v> <Plug>(unite_toggle_auto_preview)
  AutocmdFT unite imap     <silent><buffer>       <C-v> <Plug>(unite_toggle_auto_preview)
  AutocmdFT unite nmap     <silent><buffer>       <C-j> <Plug>(unite_exit)
'''

[[plugins]]
repo        = 'Shougo/neomru.vim'
lazy        = 1
on_path     = '.*'
hook_source = '''
let g:neomru#update_interval         = 1
let g:neomru#file_mru_ignore_pattern = 'fugitiveblame'
'''

[[plugins]]
repo        = 'Shougo/unite-outline'
lazy        = 1
on_source   = 'unite.vim'

# [[plugins]]
# repo        = 'osyo-manga/unite-quickfix'
# lazy        = 1
# on_source   = 'unite.vim'

[[plugins]]
repo        = 'YoshihiroIto/vim-unite-giti'
lazy        = 1
on_source   = 'unite.vim'
on_cmd      = 'GitiFetch'

# [[plugins]]
# repo        = 'tsukkee/unite-tag'
# lazy        = 1
# on_source   = 'unite.vim'

[[plugins]]
repo        = 'sgur/unite-everything'
lazy        = 1
on_source   = 'unite.vim'
hook_add    = '''
let g:unite_source_everything_full_path_search = 1
'''

# }}}
# C# {{{
# [[plugins]]
# repo        = 'OmniSharp/omnisharp-vim'
# lazy        = 1
# on_ft       = 'cs'
# hook_source = '''
# let g:omnicomplete_fetch_full_documentation = 1
# let g:Omnisharp_stop_server                 = 0
# let g:OmniSharp_typeLookupInPreview         = 0
#
# AutocmdFT cs setlocal omnifunc=OmniSharp#Complete
# AutocmdFT cs nnoremap <silent><buffer> <C-]> :<C-u>call OmniSharp#GotoDefinition()<CR>
#       \                                      zz
#       \                                      :call YOI_refresh_screen()<CR>
# '''

# }}}
# C++ {{{
[[plugins]]
repo        = 'Mizuchi/STL-Syntax'
lazy        = 1
on_ft       = 'cpp'

[[plugins]]
repo        = 'vim-jp/vim-cpp'
lazy        = 1
on_ft       = 'cpp'

[[plugins]]
repo        = 'rhysd/vim-clang-format'
lazy        = 1
on_cmd      = 'ClangFormat'
hook_source = '''
let g:clang_format#style_options = {
      \   'AccessModifierOffset':                           -4,
      \   'AllowShortIfStatementsOnASingleLine':            'false',
      \   'AlwaysBreakBeforeMultilineStrings':              'false',
      \   'BreakBeforeBraces':                              'Allman',
      \   'BreakConstructorInitializersBeforeComma':        'true',
      \   'ColumnLimit':                                    0,
      \   'ConstructorInitializerAllOnOneLineOrOnePerLine': 'false',
      \   'IndentCaseLabels':                               'true',
      \   'IndentWidth':                                    4,
      \   'UseTab':                                         'Never'
      \ }
'''

# }}}
# Go {{{
# [[plugins]]
# repo        = 'fatih/vim-go'
# lazy        = 1
# on_ft       = 'go'

# }}}
# Xml {{{
[[plugins]]
repo        = 'YoshihiroIto/vim-closetag'
lazy        = 1
on_func     = 'closetag'
hook_add    = '''
let g:closetag_filenames = '*.{html,xhtml,xml,xaml}'
'''

# }}}
# TypeScript {{{
# [[plugins]]
# repo        = 'clausreinke/typescript-tools.vim'
# lazy        = 1
# on_ft       = 'typescript'

# }}}
# Git {{{
[[plugins]]
repo        = 'tpope/vim-fugitive'
lazy        = 0
hook_add    = '''
function! YOI_update_fugitive()
  try
    call fugitive#detect(expand('<amatch>:p'))
    call lightline#update()
  catch
  endtry
endfunction

Autocmd FocusGained,FocusLost * call YOI_update_fugitive()
'''

[[plugins]]
repo        = 'airblade/vim-gitgutter'
lazy        = 1
hook_add    = '''
let g:gitgutter_map_keys           = 0
let g:gitgutter_eager              = 0
let g:gitgutter_diff_args          = ''
let g:gitgutter_sign_column_always = 1
let g:gitgutter_async              = 0

Autocmd FocusGained,FocusLost * GitGutter
'''

# [[plugins]]
# repo        = 'cohama/agit.vim'
# lazy        = 1
# on_cmd      = ['Agit', 'AgitFile']
# hook_add    = '''
# if has('win32')
#   let g:agit_enable_auto_show_commit = 0
# endif
# '''

# }}}
# ファイルタイプ {{{
[[plugins]]
repo        = 'itchyny/vim-autoft'
lazy        = 0
hook_add    = '''
let g:autoft_config = [
      \   {'filetype': 'cs',
      \    'pattern': '^\s*using'},
      \   {'filetype': 'cpp',
      \    'pattern': '^\s*#\s*\%(include\|define\)\>'},
      \   {'filetype': 'go',
      \    'pattern': '^import ('},
      \   {'filetype': 'html',
      \    'pattern': '<\%(!DOCTYPE\|html\|head\|script\|meta\|link|div\|span\)\>\|^html:5\s*$'},
      \   {'filetype': 'xml',
      \    'pattern': '<[0-9a-zA-Z]\+'},
      \ ]
'''

[[plugins]]
repo        = 'YoshihiroIto/vim-cs'
lazy        = 1
on_ft       = 'cs'

[[plugins]]
repo        = 'beyondmarc/hlsl.vim'
lazy        = 1
on_ft       = 'hlsl'

[[plugins]]
repo        = 'cespare/vim-toml'
lazy        = 1
on_ft       = ['toml', 'markdown']

# [[plugins]]
# repo        = 'jelera/vim-javascript-syntax'
# lazy        = 1
# on_ft       = 'javascript'

[[plugins]]
repo        = 'stephpy/vim-yaml'
lazy        = 1
on_ft       = 'yaml'

# [[plugins]]
# repo        = 'tikhomirov/vim-glsl'
# lazy        = 1
# on_ft       = 'glsl'

[[plugins]]
repo        = 'tpope/vim-markdown'
lazy        = 1
on_ft       = 'markdown'
hook_add    = '''
let g:markdown_fenced_languages = [
      \   'c',    'cpp', 'cs', 'go',
      \   'ruby', 'lua', 'python',
      \   'vim',
      \   'toml',
      \   'xml',  'json'
      \ ]
'''

# [[plugins]]
# repo        = 'vim-ruby/vim-ruby'
# lazy        = 1
# on_ft       = 'ruby'

[[plugins]]
repo        = 'vim-scripts/JSON.vim'
lazy        = 1
on_ft       = ['json', 'markdown']

# [[plugins]]
# repo        = 'leafgarland/typescript-vim'
# lazy        = 1
# on_ft       = 'typescript'

[[plugins]]
repo        = 'PProvost/vim-ps1'
lazy        = 1
on_ft       = 'ps1'
# }}}
# テキストオブジェクト {{{
# https://github.com/kana/vim-textobj-user/wiki
# http://d.hatena.ne.jp/osyo-manga/20130717/1374069987
[[plugins]]
repo        = 'kana/vim-textobj-user'
lazy        = 1

# #
[[plugins]]
repo        = 'anyakichi/vim-textobj-ifdef'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'a#'], ['xo', 'i#']]

# c
[[plugins]]
repo        = 'glts/vim-textobj-comment'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'ac'], ['xo', 'ic']]

# .
[[plugins]]
repo        = 'rhysd/textobj-wiw'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', '<Plug>']]
hook_add    = '''
xmap a. <Plug>(textobj-wiw-a)
xmap i. <Plug>(textobj-wiw-i)
omap a. <Plug>(textobj-wiw-a)
omap i. <Plug>(textobj-wiw-i)
'''

# e
[[plugins]]
repo        = 'kana/vim-textobj-entire'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'ae'], ['xo', 'ie']]

# i I
[[plugins]]
repo        = 'kana/vim-textobj-indent'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'ai'], ['xo', 'aI'], ['xo', 'ii'], ['xo', 'iI'], ['xo', '<Plug>(textobj-indent']]

# l
[[plugins]]
repo        = 'kana/vim-textobj-line'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'al'], ['xo', 'il']]

# b
[[plugins]]
repo        = 'rhysd/vim-textobj-anyblock'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'ab'], ['xo', 'ib']]

# v V
[[plugins]]
repo        = 'rhysd/vim-textobj-word-column'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'av'], ['xo', 'aV'], ['xo', 'iv'], ['xo', 'iV']]

# a
[[plugins]]
repo        = 'sgur/vim-textobj-parameter'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', '<Plug>']]
hook_add    = '''
xmap aa <Plug>(textobj-parameter-a)
xmap ia <Plug>(textobj-parameter-i)
omap aa <Plug>(textobj-parameter-a)
omap ia <Plug>(textobj-parameter-i)
'''

# # f{char}
# [[plugins]]
# repo        = 'thinca/vim-textobj-between'
# lazy        = 1
# depends     = 'vim-textobj-user'
# on_map      = [['xo', 'af'], ['xo', 'if']]

# x
[[plugins]]
repo        = 'whatyouhide/vim-textobj-xmlattr'
lazy        = 1
depends     = 'vim-textobj-user'
on_map      = [['xo', 'ax'], ['xo', 'ix']]

# }}}
# オペレータ {{{
# http://qiita.com/rbtnn/items/a47ed6684f1f0bc52906
[[plugins]]
repo        = 'kana/vim-operator-user'
lazy        = 1

# t
[[plugins]]
repo        = 'YoshihiroIto/vim-operator-tcomment'
lazy        = 1
depends     = ['vim-operator-user', 'tcomment_vim']
on_map      = [['nx', '<Plug>']]
hook_add    = '''
nmap t  <Plug>(operator-tcomment)
xmap t  <Plug>(operator-tcomment)
'''

# <Leader>r
[[plugins]]
repo        = 'deris/vim-rengbang'
lazy        = 1
depends     = 'vim-operator-user'
on_map      = [['nx', '<Plug>(operator-rengbang']]
on_cmd      = 'RengBang'

# R
[[plugins]]
repo        = 'kana/vim-operator-replace'
lazy        = 1
depends     = 'vim-operator-user'
on_map      = [['nx', '<Plug>']]
hook_add    = '''
map R  <Plug>(operator-replace)
'''

# S
[[plugins]]
repo        = 'rhysd/vim-operator-surround'
lazy        = 1
depends     = 'vim-operator-user'
on_map      = [['nx', '<Plug>']]
hook_add    = '''
map  S  <Plug>(operator-surround-append)
nmap Sd <Plug>(operator-surround-delete)ab
nmap Sr <Plug>(operator-surround-replace)ab
let g:operator#surround#blocks = {
      \   '-': [
      \     {
      \       'block':      ["{\<CR>", "\<CR>}"],
      \       'motionwise': ['line'            ],
      \       'keys':       ['{', '}'          ]
      \     }
      \   ]
      \ }
'''

# _
[[plugins]]
repo        = 'tyru/operator-camelize.vim'
lazy        = 1
depends     = 'vim-operator-user'
on_map      = [['nx', '<Plug>']]
hook_add    = '''
nmap <silent> _ <Plug>(operator-camelize-toggle)
xmap <silent> _ <Plug>(operator-camelize-toggle)
'''

# <C-@>
# [[plugins]]
# repo        = 'osyo-manga/vim-operator-jump_side'
# lazy        = 1
# depends     = 'vim-operator-user'
# on_map      = [['nx', '<Plug>(operator-jump']]
# hook_add    = '''
# nmap <silent> <C-@> <Plug>(operator-jump-toggle)ai
# xmap <silent> <C-@> <Plug>(operator-jump-toggle)ai
# '''

# }}}
