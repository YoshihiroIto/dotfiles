snippet DependencyProperty
abbr    DependencyProperty
options head
	#region ${1:property_name}

	public ${2:property_type} $1
	{
		get { return ($2)GetValue($1Property); }
		set { SetValue($1Property, value); }
	}

	public static readonly DependencyProperty $1Property =
		DependencyProperty.Register(
			nameof ($1),
			typeof ($2),
			typeof (${3:owner_class}),
			new FrameworkPropertyMetadata
			{
				PropertyChangedCallback = On$1Changed,
				CoerceValueCallback     = Coerce$1,
				DefaultValue            = default($2),
				BindsTwoWayByDefault    = true
			}
		);

	private static void On$1Changed(DependencyObject d, DependencyPropertyChangedEventArgs e)
	{
		Debug.Assert(d is $3);
		var self = d as $3;
	}

	private static object Coerce$1(DependencyObject d, object value)
	{
		Debug.Assert(d is $3);
		var self = d as $3;

		return value;
	}

	#endregion
	${0}

snippet props
abbr    Property (SetProperty)
options head
	#region ${1:property_name}

	private ${2:property_type} _$1;

	public $2 $1
	{
		get { return _$1; }
		set { SetProperty(ref _$1, value); }
	}

	#endregion
	${0}

snippet propr
abbr    Property (RaisePropertyChanged)
options head
	#region ${1:property_name}

	private ${2:property_type} _$1;

	public $2 $1
	{
		get { return _$1; }
		set
		{ 
			if (_$1 == value)
				return;

			_$1 = value;
			RaisePropertyChanged(() => $1);
		}
	}

	#endregion
	${0}

snippet propa
abbr    Auto Property
options head
	public ${1:TValue} ${2:name} { get; set; }

snippet comv
abbr    ViewModelCommand
options head
	#region ${1:command_name}Command

	private ViewModelCommand _$1Command;

	public ViewModelCommand $1Command
	{
		get { return _$1Command ?? (_$1Command = new ViewModelCommand($1, Can$1)); }
	}

	private void $1()
	{
	}

	private bool Can$1()
	{
		return true;
	}

	#endregion
	${0}

snippet coml
abbr    ListenerCommand
options head
	#region ${1:command_name}Command

	private ListenerCommand<${2:message_type}> _$1Command;

	public ListenerCommand<$2> $1Command
	{
		get { return _$1Command ?? (_$1Command = new ListenerCommand<$2>($1, Can$1)); }
	}

	private void $1($2 message)
	{
	}

	private bool Can$1()
	{
		return true;
	}

	#endregion
	${0}

snippet ///
abbr    summary
options head
	/// <summary>
	/// ${1}
	/// </summary>
	${0}

snippet using
abbr    using block
options head
	using (var ${1:value} = new ${2:TValue}())
	{
		${0}
	}

snippet AnonymousDisposable
abbr    AnonymousDisposable block
options head
	using (new AnonymousDisposable(() => ${1}))
	{
		${0}
	}

snippet IDispoable
abbr    IDisposable
options head
	public class ${1:class_name} : IDisposable
	{
		#region IDisposable
		private bool _isDisposed;

		~$1()
		{
			Dispose(false);
		}

		public void Dispose()
		{
			Dispose(true);

			GC.SuppressFinalize(this);
		}

		protected virtual void Dispose(bool disposing)
		{
			if (_isDisposed)
				return;

			if (disposing)
			{
				// Disposing of managed resources.
				${0};
			}

			// Disposing of unmanaged resources.
			;

			_isDisposed = true;
		}
		#endregion
	}

snippet Dispoable override
abbr    protected override void Dispose(bool disposing)
options head
	protected override void Dispose(bool disposing)
	{
		if (disposing)
		{
			${0}
		}

		base.Dispose(disposing);
	}

snippet Parallel ForEach
abbr    Parallel.ForEach
options head
	Parallel.ForEach(${1:items}, ${2:item} =>
	{
		${0}
	});

snippet Parallel For
abbr    Parallel.For
options head
	Parallel.For(0, ${1:max}, ${2:i} =>
	{
		${0}
	});

snippet TryGetValue
abbr    Dictionary.TryGetValue
options head
	var value = default(${1:TValue});
	if (${2:dict}.TryGetValue(${3:key}, out value))
	{
		${0}
	}

snippet GetOrAdd
abbr    ConcurrentDictionary.GetOrAdd
options head
	var value = ${1:dict}.GetOrAdd(${2:key}, key =>
	{
		${0}
	});

snippet Task Run WaitAll
abbr    Task.Run
options head
	var task = Task.Run(() => ${0});
	Task.WaitAll(new []{task});

snippet Serializable
	Serializable

snippet readonly
	readonly

snippet Enumerable
abbr    Enumerable
	Enumerable

snippet IEnumerable
abbr    IEnumerable
	IEnumerable<${1:T}> ${0}

snippet Dictionary
abbr    Dictionary
	Dictionary<${1:TKey}, ${2:TValue}> ${0}

snippet ObservableCollection
abbr    ObservableCollection
	ObservableCollection<${1:T}> ${0}

snippet new List
abbr    new List
alias   List
options head
	var ${1:value} = new List<${2:T}>();
	${0}

snippet new HashSet
abbr    new HashSet
alias   HashSet
options head
	var ${1:value} = new HashSet<${2:T}>();
	${0}

snippet new Dictionary
abbr    new Dictionary
alias   Dictionary
options head
	var ${1:value} = new Dictionary<${2:TKey}, ${3:TValue}>();
	${0}

snippet new ReadOnlyDictionary
abbr    new ReadOnlyDictionary
alias   ReadOnlyDictionary
options head
	public static readonly ReadOnlyDictionary<${1:TKey}, ${2:TValue}> ${3:value} = new ReadOnlyDictionary<$1, $2>(
		new Dictionary<$1, $2>
		{
			{${0}},
		});

snippet new ObservableCollection
abbr    new ObservableCollection
alias   ObservableCollection
	new ObservableCollection<${1:T}>();

snippet string IsNullOrEmpty
abbr    if string.IsNullOrEmpty
alias   IsNullOrEmpty
options head
	if (string.IsNullOrEmpty(${1:value}))
	{
		${0}
	}

snippet throw NotImplementedException
options head
	throw new NotImplementedException(${0});

snippet throw NotSupportedException
options head
	throw new NotSupportedException(${0});

snippet throw InvalidOperationException
options head
	throw new InvalidOperationException(${0});

snippet NotImplementedException
	NotImplementedException

snippet NotSupportedException
	NotSupportedException

snippet InvalidOperationException
	InvalidOperationException

# vim:set noexpandtab :
