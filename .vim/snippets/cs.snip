snippet		dep
abbr		DependencyProperty
	#region ${1:property_name}
	public ${2:property_type} $1
	{
		get { return ($2)GetValue($1Property); }
		set { SetValue($1Property, value); }
	}

	public static readonly DependencyProperty $1Property =
		DependencyProperty.Register(
			"$1",
			typeof($2),
			typeof(${3:owner_class}),
			new FrameworkPropertyMetadata
			{
				PropertyChangedCallback = On$1Changed,
				CoerceValueCallback     = Coerce$1,
				DefaultValue            = default($2),
				BindsTwoWayByDefault    = true
			}
		);

	private static void On$1Changed(DependencyObject d, DependencyPropertyChangedEventArgs e)
	{
		Debug.Assert(d is $3);
		var self = d as $3;
	}

	private static object Coerce$1(DependencyObject d, object value)
	{
		Debug.Assert(d is $3);
		var self = d as $3;

		return value;
	}
	#endregion
	${0}

snippet		props
abbr		Property (SetProperty)
	#region ${1:property_name}
	private ${2:property_type} _$1;
	public $2 $1
	{
		get { return _$1; }
		set { SetProperty(ref _$1, value); }
	}
	#endregion
	${0}

snippet		propr
abbr		Property (RaisePropertyChanged)
	#region ${1:property_name}
	private ${2:property_type} _$1;
	public $2 $1
	{
		get { return _$1; }
		set
		{ 
			if (_$1 == value)
				return;

			_$1 = value;
			RaisePropertyChanged(() => $1);
		}
	}
	#endregion
	${0}

snippet		propa
abbr		Auto Property
	public ${1:TValue} ${2:name} { get; set; }
	${0}

snippet		comv
abbr		Property (ViewModelCommand)
	#region ${1:command_name}Command
	private ViewModelCommand _$1Command;
	public ViewModelCommand $1Command
	{
		get { return _$1Command ?? (_$1Command = new ViewModelCommand($1, Can$1)); }
	}

	private void $1()
	{
	}

	private bool Can$1()
	{
		return true;
	}
	#endregion
	${0}

snippet		coml
abbr		Property (ListenerCommand)
	#region ${1:command_name}Command
	private ListenerCommand<${2:message_type}> _$1Command;
	public ListenerCommand<$2> $1Command
	{
		get { return _$1Command ?? (_$1Command = new ListenerCommand<$2>($1, Can$1)); }
	}

	private void $1($2 message)
	{
	}

	private bool Can$1()
	{
		return true;
	}
	#endregion
	${0}

snippet		singleton
abbr		Singleton
	private ${1:class_name}(){}
	private static readonly $1 _Instance = new $1();
	public static $1 Instance
	{
		get { return _Instance; }
	}
	${0}

snippet		///
abbr		summary
	/// <summary>
	/// ${0}
	/// </summary>

snippet		if
abbr		if
	if (${1})
	{
		${0}
	}

snippet		else
abbr		else
	else
	{
		${0}
	}

snippet		foreach
abbr		foreach
	foreach (var ${1:item} in ${2:items})
	{
		${0}
	}

snippet		for
abbr		for
	for (var ${1:i} = 0;$1 != ${2:max};++ $1)
	{
		${0}
	}

snippet		while
abbr		while
	while (${1})
	{
		${0}
	}

snippet		do
abbr		do 〜 while
	do
	{
		${0}
	}
	while (${1});

snippet		yield return
abbr		yield return
	yield return ${0};

snippet		try
abbr		try 〜 catch 〜 finally
	try
	{
		${0}
	}
	catch (Exception e)
	{
	}
	finally
	{
	}

snippet		switch
abbr		switch 〜 case
	switch (${1:value})
	{
		case ${2}:
			${0}
			break;

		default:
			break;
	}

snippet		using
abbr		using block
	using (var ${1:value} = new ${2:TValue}())
	{
		${0}
	}

snippet		Dispose
abbr		protected override void Dispose(bool disposing)
	protected override void Dispose(bool disposing)
	{
		if (disposing)
		{
			${0}
		}

		base.Dispose(disposing);
	}

snippet		Parallel ForEach
abbr		Parallel.ForEach
	Parallel.ForEach(${1:items}, ${2:item} =>
	{
		${0}
	});

snippet		Parallel For
abbr		Parallel.For
	Parallel.For(0, ${1:max}, ${2:i} =>
	{
		${0}
	});

snippet		TryGetValue
abbr		Dictionary.TryGetValue
	${1:TValue} value = default($1);
	if (${2:dict}.TryGetValue(${3:key}, out value))
	{
		${0}
	}

snippet		GetOrAdd
abbr		ConcurrentDictionary.GetOrAdd
	var value = ${1:dict}.GetOrAdd(${2:key}, key =>
	{
		${0}
	});

snippet		Task Run WaitAll
abbr		Task.Run
	var task = Task.Run(() => ${0});
	Task.WaitAll(new []{task});

snippet		IDisposable
	IDisposable

snippet		Serializable
	Serializable

snippet		readonly
	readonly

snippet		Enumerable
abbr		Enumerable
	Enumerable

snippet		IEnumerable
abbr		IEnumerable
	IEnumerable<${1:T}> ${0}

snippet		ObservableCollection
abbr		ObservableCollection
	ObservableCollection<${1:T}> ${0}

snippet		Dictionary
abbr		Dictionary
	Dictionary<${1:TKey}, ${2:TValue}> ${0}

snippet		new List
abbr		new List
	var ${1:value} = new List<${2:T}>();
	${0}

snippet		new HashSet
abbr		new HashSet
	var ${1:value} = new HashSet<${2:T}>();
	${0}

snippet		new Dictionary
abbr		new Dictionary
	var ${1:value} = new Dictionary<${2:TKey}, ${3:TValue}>();
	${0}

snippet		throw NotImplementedException
	throw new NotImplementedException(${0});

snippet		throw NotSupportedException
	throw new NotSupportedException(${0});

snippet		throw InvalidOperationException
	throw new InvalidOperationException(${0});

snippet		NotImplementedException
	NotImplementedException

snippet		NotSupportedException
	NotSupportedException

snippet		InvalidOperationException
	InvalidOperationException

snippet		string IsNullOrEmpty
abbr		if string.IsNullOrEmpty
	if (string.IsNullOrEmpty(${1:value}))
	{
		${0}
	}

# vim:set noexpandtab :
